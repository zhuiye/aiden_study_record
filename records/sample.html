<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script>
      /**
       * 递归通常涉及函数自身的调用
       * 每个递归函数都必须有基线条件, 停止的条件
       *
       * 函数的调用, 也是用"栈"存储,称之为调用栈
       *
       */

      function countN(n) {
        if (n === 1 || n === 0) {
          return 1;
        }
        return n * countN(n - 1);
      }

      // Dom  树 Dom 节点,内部节点 函数尾调用   https://www.ruanyifeng.com/blog/2015/04/tail-call.html
      /*
                   叶节点:无子树
                   内部节点:有子树

                   节点的深度:取决于有多少个祖先
                   树的高度 取决所有节点的最大值

                   左子树,


                   二叉树搜索树  值(左<中<右)

                   键
                   中 ->都是增对父节点来的
                   先
                   后

                   递归:重复的操作~~,或许可能返回一个值做为上一个值的结果
                */

      class CNode {
        constructor(key) {
          this.key = key;
          this.left = null;
          this.right = null;
        }
      }
      // 目标,构建一个二叉树
      class BFSearchTree {
        constructor() {
          this.root = null;
        }

        push(el) {
          const elNode = new CNode(el);
          if (this.root === null) {
            this.root = elNode;
          } else {
            this.insert(this.root, elNode);
          }
        }

        insert(node, elNode) {
          // if (node === null) {
          //   console.log(node, elNode);
          //   node = elNode;
          //   return;
          // }
          if (node.key > elNode.key) {
            if (node.left === null) {
              node.left = elNode;
            } else {
              this.insert(node.left, elNode);
            }
          }

          if (node.key < elNode.key) {
            if (node.right === null) {
              node.right = elNode;
            } else {
              this.insert(node.right, elNode);
            }
          }
        }
        // 来一个查找最小值

        getMin() {
          const current = this.root;
          let leftNode = current.left;
          if (leftNode === null) {
            return current.key;
          }
          while (leftNode.left !== null) {
            leftNode = leftNode.left;
          }
          return leftNode.key;
        }

        getMax() {
          const current = this.root;
          let rNode = current.right;
          if (rNode === null) {
            return current.key;
          }
          while (rNode.right !== null) {
            rNode = rNode.right;
          }
          return rNode.key;
        }

        center(callback) {
          if (this.root === null) {
            return;
          }
          // 中序遍历
          this.centerHelp(this.root, callback);
        }

        centerHelp(node, callback) {
          if (node === null) {
            return;
          }
          this.centerHelp(node.left, callback);
          callback(node.key);
          this.centerHelp(node.right, callback);
        }
        // 先序遍历
        firstPrint(callback) {
          if (this.root === null) {
            return;
          }
          // 中序遍历
          this.firstHelp(this.root, callback);
        }

        firstHelp(node, callback) {
          if (node === null) {
            return;
          }
          callback(node.key);
          this.firstHelp(node.left, callback);
          this.firstHelp(node.right, callback);
        }

        lastPrint(callback) {
          if (this.root === null) {
            return;
          }
          // 后续
          this.lastHelp(this.root, callback);
        }
        lastHelp(node, callback) {
          if (node === null) {
            return;
          }
          this.lastHelp(node.left, callback);
          this.lastHelp(node.right, callback);
          callback(node.key);
        }

        search(key) {
          // 搜索一个特定的值,是否在二叉树中
          if (this.root === null) {
            return false;
          }
          return this.findSearchNode(this.root, key);
        }
        findSearchNode(node, key) {
          if (node === null) {
            return false;
          }
          if (node.key > key) {
            return this.findSearchNode(node.left, key);
          }
          if (node.key < key) {
            return this.findSearchNode(node.right, key);
          }

          return true;
        }

        remove(key) {
          this.root = this.removeHelp(this.root, key);
        }

        removeHelp(node, key) {
          if (node === null) {
            return null;
          }
          if (node.key > key) {
            // 找到节点,
            node.left = this.removeHelp(node.left);
            return node;
          } else if (node.key < key) {
            node.right = this.removeHelp(node.right);
            return node;
          } else {
            if (node.left === null && node.right === null) {
              node = null;
              return node;
            }
            if (node.left === null) {
              node = node.right;
              return node;
            } else if (node.right === null) {
              node = node.left; // {16}
              return node; // {17}
            }
            // 第三种情况 该节点最小值

            let minNode = this.getMin(node.right);
            node.key = minNode.key;
            node.right = this.removeHelp(node.right, minNode.key);
            return node;
          }
        }
        // 计算节点高度的代码 --如何具有递归的思维
        getNodeHeight(node) {
          if (node == null) {
            return -1;
          }
          return (
            Math.max(
              this.getNodeHeight(node.left),
              this.getNodeHeight(node.right)
            ) + 1
          );
        }
      }

      // const tree = new BFSearchTree();
      // tree.push(6);
      // tree.push(3);
      // tree.push(1);
      // tree.push(9);
      // tree.push(2);
      // tree.push(8);
      // tree.push(11);
      // 2天 -> 2个人的话, 有一个蓝眼-不确定自己是不是, 第一天 ,最后
      // 怎么确定自己是不是红眼,如何知道自己是红眼?
      // 2个人蓝眼睛的时候,100人我看 98人蓝眼睛 1人红眼睛

      /*
                              6
                            3   9
                          1  8   11
                           2
                        第一种: 取左子数最左值补上
                        第二种: 如果删除没有子节点 ,最好删除

                    */

      // console.log(tree.getMin());
      // console.log(tree.getMax());

      // tree.center((val) => {
      //   console.log(val);
      // });
      // tree.firstPrint((val) => {
      //   console.log(val);
      // });
      // tree.lastPrint((val) => {
      //   console.log(val);
      // });
      // console.log(tree.search(5));

      // 左旋 ,右旋
      // 红黑树
      // https://zhuanlan.zhihu.com/p/56066942
      // https://zhuanlan.zhihu.com/p/79980618
      // https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
      // https://zhuanlan.zhihu.com/p/31805309
      /*

                  分治法, 经常需要递归
                  memories:

                    队列的实现 储存数据用对象存储(先进先出) ,双端队列(末尾两端操作可实现进出操作),(优先队列?)击鼓传花,以及回文字符串,利用双端队列, javascript中函数的调用以及任务队列
                    hashMap的实现,目的 为了更快的检索数据,根据对象的key 生成散列hash作为"查找时索引",模拟的数据结构也是javascript 中的对象,
                    生成的hash可能重复,即存在冲突,有两种解决的方法,分离链表,存储的数据格式为一个链表,第二线性探索法,如果某个位置已经被添加数据了
                    position+1,下一个填充,但删除要特殊处理

                    hash 表就是这么一个数据结构就行了,实际上是一种映射

                    一种数据结构:
                    时间->牺牲空间

                    两数之和 ->利用hash结构,差值做key 然后进行查找
                    整数反转 ->利用数学的迭代公式
                    整数回文数 ->反转一半进行比较
                    罗马数转整数 ->利用hash表

                    Map 与 Object 对象的区别
                    键有序
                    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map

                    链表:单链表,双向链表,循环链表
                    树:二叉树,树的遍历,avl树 以及红黑树

                    因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

                */

      // function Heap() {

      // }
      /*
                        实现一个贪吃蛇游戏，贪吃蛇一开始在［0，0］位置且长度为1。每当贪吃蛇吃到食物，长度和获得的分数都增加一。
                        对于每次move输出move之后的分数。如果贪吃蛇走出边界或和自己的身体相撞则游戏结束，输出－1。下面地图中 S是Snake， F是food
                   */
      /*
                       5 4 2 3 9

                       5 4 3 9 2

                       5 4 9 3 2

                       5 9 4 3 2

                       9 5 4 3 2

                       总结:冒泡,选择,插入



                    */
      // 0 1 2 3 4

      function bubbleSort(arr) {
        const data = arr.slice();
        for (let i = 0; i < data.length - 1; i++) {
          // 减去i,表示已经比较的次数
          for (let j = 0; j < data.length - 1 - i; j++) {
            if (data[j] < data[j + 1]) {
              // 交换
              let temp = data[j];
              data[j] = data[j + 1];
              data[j + 1] = temp;
            }
          }
        }
        return data;
      }

      // console.log(bubbleSort([1, 2, 3, 4, 5, 6, 7]))
      /*
                       选择排序,找每一轮中的最小值,调换位置,直到 循环完,
                       5 4 2 3 9

                       2 4 5 3 9

                       2 3 5 4 9

                       2 3 4 5 9

                       2 3 4 5 9

                       插入排序:
                    */
      function selectSort(arr) {
        const data = arr.slice();
        for (let i = 0; i < data.length - 1; i++) {
          let min = data[i];
          let initMin = min;
          let minIndex = i;
          for (let j = i; j < data.length; j++) {
            if (min > data[j]) {
              min = data[j];
              minIndex = j;
            }
          }
          data[i] = min;
          data[minIndex] = initMin;
        }

        return data;
      }
      /*
                       插入排序

                       5 4 2 3 9

                       4 5 2 3 9

                       2 4 5 3 9

                       2 3 4 5 9

                       2 3 4 5 9

                       插入排序的思想比较简单,但代码的实现,就有点绕

                      */

      // console.log(selectSort([1, 8, 4, 3, 5, 1]))

      function insertionSort(arr) {
        let temp;
        for (let i = 1; i < arr.length; i++) {
          temp = arr[i];
          let j = i;
          while (j > 0 && arr[j - 1] - temp > 0) {
            arr[j] = arr[j - 1];
            j--;
          }
          // 插入
          arr[j] = temp;
        }
        return arr;
      }

      // console.log(insertionSort([5, 4, 2, 3, 9]));
      /*
                      5 4 2 3 9

                      5 4 2  3 9
                      5 4 2  3 9
                      5  4 2  3 9
                      2 4 5  3 9
                      2 3 4 5 9
                      归并排序
                      [2, 1, 4, 3]

                     const left= mergeSort([2, 1])->{
                       const left=[2],
                       const right=[1]

                       array=[1,2]
                     }

                     const right =mergeSort([4,3])

                     归并的思想是在是太厉害了,知道思想是一回事,实现又是一回事

                     分治

                     分解->解决->合并

                     分解：分解原问题为结构相同的子问题（即寻找子问题）
                     解决：当分解到容易求解的边界后，进行递归求解
                     合并：将子问题的解合并成原问题的解


                     给定一个含有数字和运算符的字符串，为表达式添加括号，
                     改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含+,-以及*。




                     示例 1:输入: "2-1-1"
                      输出: [0, 2]
                      解释:
                      ((2-1)-1) = 0
                      (2-(1-1)) = 2

                      示例 2:输入: "2*3-4*5"
                      输出: [-34, -14, -10, -10, 10]
                      解释:
                      (2*(3-(4*5))) = -34
                      ((2*3)-(4*5)) = -14
                      ((2*(3-4))*5) = -10
                      (2*((3-4)*5)) = -10
                      (((2*3)-4)*5) = 10

                      有点明白了,栏图


                    */

      function mergeSort(array) {
        if (array.length > 1) {
          // {1}
          const { length } = array;
          const middle = Math.floor(length / 2); // {2}
          const left = mergeSort(array.slice(0, middle)); // {3}
          const right = mergeSort(array.slice(middle, length)); // {4}
          // console.log(left, right)

          array = merge(left, right); // {5}
        }
        return array;
      }

      function merge(left, right) {
        let i = 0; // {6}
        let j = 0;
        const result = [];
        // [1,2]  [3,4]
        while (i < left.length && j < right.length) {
          // {7}
          result.push(left[i] < right[j] ? left[i++] : right[j++]); // {8}
        }

        return result.concat(i < left.length ? left.slice(i) : right.slice(j)); // {9}
      }

      // console.log(mergeSort([7, 2, 1, 4, 3]));

      /*
                      "2-1-1"
                      2 1-1
                    2   1 1
                    */
      // console.log("1+23456".substring(0, 1));
      // console.log("1+23456".slice(2));

      function diffWaysToCompute(str) {
        if (Number(str)) {
          return [Number(str)];
        }

        let len = str.length;
        const result = [];

        for (let i = 0; i < len; i++) {
          if (str[i] === "+" || str[i] === "-" || str[i] === "*") {
            let left = diffWaysToCompute(str.substring(0, i));
            let right = diffWaysToCompute(str.slice(i + 1));
            for (let lv of left) {
              for (let rv of right) {
                switch (str[i]) {
                  case "+":
                    result.push(lv + rv);
                    break;
                  case "-":
                    result.push(lv - rv);
                    break;
                  case "*":
                    result.push(lv * rv);
                }
              }
            }
          }
        }
        return result;
      }
      // console.log(diffWaysToCompute("2*3-4*5"))
      /*
                      memories
                        分治法:
                        查找子问题(这个一般不容易看出),
                        分解子问题(进行切割,一般套路,产生一个left ,right ,)
                        合并操作(然后有一个函数,对这个传入的left,right进行处理,合并出小的结果,然后对这个结构进行返回)
                        hash:为什么用hash
                        冒泡排序:一轮下来,交换位置,把最大的排在尾端,或者前端
                        选择排序:选择每一轮中的最大值,一次替换
                        插入排序:遍历交换,小的排前面,或者后面
                        :分治算法思想:归并排序,运算符组合结构,
                        有效括号:栈的运用
                        数组中去重:可以运用栈,或者,和下一个做比较,然后删除去重元素,
                        查找字符串数组中的最长公共子串:水平扫描发,分治法
                        本质跟普通的暴力法,没什么两样的,这个思想太绕了

                        分治法:
                        1. 寻找分割点 --一般是对半分割 生成左数据,右数据
                        2. 利用递归  --函数不断调用--- 递归结束条件,有两个返回值,一个是"结果返回值",一个是递归返回值
                        3. 解决小问题的结果函数
                    */

      const searchCommonStr = function (strArr) {
        let prefix = strArr[0];

        for (let i = 1; i < strArr.length; i++) {
          while (strArr[i].indexOf(prefix) != 0) {
            prefix = prefix.substring(0, prefix.length - 1);
            //  高~~,实在是神仙想法
            if (!prefix) return "";
          }
        }
        return prefix;
      };

      const searchCommonStrTwo = function (strArr) {
        let prefix;
        if (strArr.length === 1) {
          return strArr[0];
        }

        if (strArr.length > 1) {
          const length = strArr.length;
          const mod = Math.floor(length / 2);
          let left = searchCommonStrTwo(strArr.slice(0, mod));
          let right = searchCommonStrTwo(strArr.slice(mod));
          prefix = searchTowStr(left, right);
        }

        return prefix;

        // let prefix = strArr[0];
      };

      function searchTowStr(left, right) {
        let prefix = left;
        while (right.indexOf(prefix) !== 0) {
          prefix = prefix.substring(0, prefix.length - 1);
          if (!prefix) return "";
        }
        return prefix;
      }

      // console.log(searchCommonStrTwo(["axx", "xx3", "xx1"]));

      //  console.log('xxxx'.indexOf('xxa', 0)) 提两个字符串之间
      /*
                          public int removeDuplicates(int[] nums) {
                              if (nums.length == 0) return 0;
                              int i = 0;
                              for (int j = 1; j < nums.length; j++) {
                                  if (nums[j] != nums[i]) {
                                      i++;
                                      nums[i] = nums[j];
                                  }
                              }
                              return i + 1;
                          }
                          [1,2,3,2,3]

                          将两个**升序链表合并为一个新的升序链表**并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

                          示例：



                      */
      /* 链表的合并*/

      class LinkNode {
        constructor(el) {
          this.el = el;
          this.next = null;
        }
      }

      class LinkTable {
        constructor() {
          this.header = null;
        }

        insert(el) {
          const node = new LinkNode(el);
          if (this.header === null) {
            this.header = node;
            return true;
          }
          let current = this.header;
          while (current.next !== null) {
            current = current.next;
          }
          current.next = node;
          return true;
        }

        remove(el) {
          /*
                            1->2->4
                         */
          let pre = this.header;
          if (pre.el === el) {
            this.header = pre.next;

            pre.next = null;
            return pre;
          }

          let nextNode = pre.next;

          while (nextNode !== null) {
            if (nextNode.el === el) {
              pre.next = nextNode.next;
              nextNode.next = null;
              return nextNode;
            }
            pre = nextNode;
            nextNode = nextNode.next;
          }
          return false;
          // current.next = node;
        }

        print() {
          let current = this.header;
          if (current == null) {
            return;
          }
          let str = current.el;
          while (current.next !== null) {
            current = current.next;

            str = str + "->" + current.el;
          }
          console.log(str);
        }
      }

      const Link1 = new LinkTable();
      Link1.insert(1);

      const Link2 = new LinkTable();
      Link2.insert(0);
      Link2.insert(0);

      const mergeTwoLists = function (l1, l2) {
        let header1 = l1.header;
        let preNode2 = l2.header;

        while (header1 !== null) {
          const outVal = header1.el;
          const node1 = l1.remove(outVal);
          if (outVal <= preNode2.el) {
            node1.next = preNode2;
            l2.header = node1;
          } else {
            while (preNode2 !== null) {
              if (
                outVal > preNode2.el &&
                ((preNode2.next !== null && preNode2.next.el >= outVal) ||
                  preNode2.next === null)
              ) {
                node1.next = preNode2.next;
                preNode2.next = node1;
                break;
              }
              preNode2 = preNode2.next;
            }
          }
          preNode2 = l2.header;
          header1 = l1.header;
        }

        return l2;
      };

      // mergeTwoLists(Link1, Link2).print();

      /*
                         1  3  <<====>> 2 4
                    也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。
                    我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：

                    class Solution {
                        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
                            if (l1 == null) {
                                return l2;
                            }
                            else if (l2 == null) {
                                return l1;
                            }
                            else if (l1.val < l2.val) {
                                l1.next = mergeTwoLists(l1.next, l2);
                                return l1;
                            }
                            else {
                                l2.next = mergeTwoLists(l1, l2.next);
                                return l2;
                            }

                        }
                    }

                    链表为：1->2->3->4。反转后为 4->3->2->1
                    webpack 用来连接模块化应用程序所需的所有代码
                     4->3->2->1

                     1 2 3  3 2 1

                1
                2
                3
                4
                   {}

                */

      const testLink = {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: null,
          },
        },
      };

      function revertLink(testLink) {
        if (!testLink) {
          return testLink;
        } else {
          let result = revertLink(testLink.next);
          if (result === null) {
            return testLink;
          }
          let header = result;
          while (header.next !== null) {
            header = header.next;
          }

          header.next = testLink;
          testLink.next = null;

          return result;
        }
      }
      // console.log(revertLink(testLink));

      /*
                  给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

                  不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

                  元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



                  示例 1:

                  给定 nums = [3,2,2,3,1], val = 3,

                  [2,2,1,3,3]

                  函数应该返回新的长度 3, 并且 nums 中为 2,2 1。

                  你不需要考虑数组中超出新长度后面的元素。
                  示例 2:

                  给定 nums = [0,1,2,2,3,0,4,2], val = 2,
                  []

                  函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

                  注意这五个元素可为任意顺序。

                  你不需要考虑数组中超出新长度后面的元素。


                  [1,1,2,2,3,4]
                  [1,2,3,4,5,6]
                  [1,1,2,2,3,4]


                */

      // const removeElement = function (nums, val) {
      //   for (let i = 0; i < nums.length; ) {
      //     if (nums[i] === val) {
      //       nums.splice(i, 1);
      //       i = 0;
      //     } else {
      //       i++;
      //     }
      //   }
      //   return nums.length;
      // };
      // const test = [3, 2, 2, 3,1];

      // console.log(removeElement(test, 3));
      // console.log(test);
      function removeElement(nums, val) {
        let i = 0;
        for (let j = 0; j < nums.length; j++) {
          if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
          }
        }
        console.log(nums);
        return i;
      }
      // removeElement([3, 2, 2, 3, 1], 3);
      /*



                   1->2

                   输入: haystack = "hello", needle = "ll"
                      输出: 2
                      示例 2:

                  输入: haystack = "aaaaa", needle = "bba"
                      输出: -1

                  */
      // var strStr = function (haystack, needle) {
      //   if (needle === "") {
      //     return 0;
      //   }
      //   let index = -1;
      //   for (let i = 0; i < haystack.length; i++) {
      //     for (let j = 0; j < needle.length; j++) {
      //       if (haystack[i] === needle[j]) {
      //       }
      //     }
      //   }   [1,1,2,3,3]
      // };

      // const sortLink = {
      //   val: 1,
      //   next: {
      //     val: 1,
      //     next: {
      //       val: 2,
      //       next: {
      //         val: 3,
      //         next: {
      //           val: 3,
      //           next: null,
      //         },
      //       },
      //     },
      //   },
      // };

      // function deleteDuplicates(head) {
      //   if (!head) {
      //     return null;
      //   } else {
      //     let result = deleteDuplicates(head.next);
      //     if (result === null) {
      //       return head;
      //     }
      //     if (result.val !== head.val) {
      //       head.next = result;
      //       return head;
      //     } else {
      //       return result;
      //     }
      //   }
      // }

      // console.log(deleteDuplicates(sortLink));

      // function searchIndexOf(arr,value){

      //   const len= arr.length;
      //   let i=0;
      //   // if(arr[0]>value){
      //   //   return 0
      //   // }
      //   // if(arr[len-1]< value){
      //   //   return len;
      //   // }

      //   const middle= arr[Math.floor(len/2)];
      //   if(middle>value){
      //      const arr=arr.slice(middle)
      //   }else if(middle< value){

      //   }else {
      //     return middle
      //   }
      //   while(){

      //   }

      // }

      /*
                数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
                // 这个值只能在0~max 最大值和最小值区间
                输入：[3,0,1] [0,2]
                输出：2


                示例 2：
                输入：[9,6,4,2,3,5,7,0,1]
                输出：8

             */

      // function missingNumber(arr) {
      //   let hash = {};
      //   for (let i = 0; i < arr.length; i++) {
      //     hash[arr[i]] = i;
      //   }

      //   for (let i = 0; i < arr.length + 1; i++) {
      //     if (hash[i] === undefined) {
      //       return i;
      //     }
      //   }
      // }
      // 利用异或的特性，res = res ^ x ^ x。对同一个值异或两次，
      // 那么结果等于它本身，所以我们对res从0-nums.length进行异或，同时对nums数组中的值进行异或，
      // 出现重复的会消失，所以最后res的值是只出现一次的数字，也就是nums数组中缺失的那个数字。

      // function missingNumber(arr) {
      //   let min = 0;

      //   for (let i = 0; i < arr.length + 1; i++) {
      //     let flag = false;
      //     for (let value of arr) {
      //       if (min === value) {
      //         flag = true;
      //         break;
      //       }
      //     }
      //     if (!flag) {
      //       return min;
      //     }
      //     min++;
      //   }
      // }

      // console.log(missingNumber([0]));

      /*


                    外观序列:
                      1.     1           1
                      2.     11          1 个 1
                      3.     21          2 个 1
                      4.     1211        1 个 2  1 个 1
                      5.     111221      1 个 1  1 个 2  2 个 1

                */

      const countAndSay = function (n) {
        if (n === 1) {
          return "1";
        }
        let base = countAndSay(n - 1);
        let result = "";
        let count = 1;
        for (let i = 0; i < base.length; i++) {
          if (base[i] === base[i + 1]) {
            count = count + 1;
          } else {
            result += count + base[i];
            count = 1;
          }
        }
        return result;
      };

      // console.log(countAndSay(6));

      /*
                  给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
                  最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
                  你可以假设除了整数 0 之外，这个整数不会以零开头。
                  示例 1:
                  输入: [1,2,3]
                  输出: [1,2,4]
                  解释: 输入数组表示数字 123。
                  示例 2:

                  输入: [4,3,2,1]
                  输出: [4,3,2,2]
                  解释: 输入数组表示数字 4321。

                */

      // var plusOne = function (digits) {
      //   let flag = false;
      //   let result = [];
      //   for (let i = digits.length - 1; i < 0; i--) {
      //     if (digits[i] + 1 === 10|| flag ) {
      //       result.unshift(0);
      //     } else {
      //       result.unshift(digits[i] + 1);
      //       flag = true;
      //     }
      //   }
      // };

      // console.log(plusOne([1, 9]));

      // 挺简单的,想复杂了 .....
      // var addBinary = function (a, b) {
      //   const n = a.length,
      //     m = b.length;
      //   if (n < m) return addBinary(b, a);
      //   const L = Math.max(n, m);

      //   const sb = [];
      //   let carry = 0,
      //     j = m - 1;
      //   for (let i = L - 1; i > -1; --i) {
      //     if (a[i] == "1") ++carry;
      //     if (j > -1 && b[j--] == "1") ++carry;

      //     if (carry % 2 == 1) sb.push("1");
      //     else sb.push("0");

      //     carry = Math.floor(carry / 2);
      //   }
      //   if (carry == 1) sb.push("1");
      //   return sb.reverse().join("");
      // };
      // console.log(addBinary("1010", "1011"));

      /**
       * Definition for a binary tree node.
       * function TreeNode(val) {
       *     this.val = val;
       *     this.left = this.right = null;
       * }
       */
      /**
       * @param {TreeNode} p
       * @param {TreeNode} q
       * @return {boolean}
       */
      const p = {
        val: 1,
        left: {
          val: 2,
          left: null,
          right: null,
        },
        right: null,
      };

      const q = {
        val: 1,
        left: null,
        right: {
          val: 2,
          left: null,
          right: null,
        },
      };
      var isSameTree = function (p, q) {
        let tree1 = [];
        let tree2 = [];
        helper(p, tree1);
        helper(q, tree2);

        return tree1.toString() === tree2.toString();
      };
      const helper = (tree, result) => {
        if (tree === null) {
          result.push("null");
          return;
        }
        const left = helper(tree.left, result);
        const right = helper(tree.right, result);
        result.push(tree.val);
      };
      // console.log(isSameTree(p, q));
      /*

               实现 int sqrt(int x) 函数。

               计算并返回 x 的平方根，其中 x 是非负整数。

               由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

               示例 1:

               输入: 4
               输出: 2
               示例 2:

               输入: 8
               输出: 2
               说明: 8 的平方根是 2.82842...,
               由于返回类型是整数，小数部分将被舍去。
                 8/2 /2/2

             */

      /**
       * @param {number} x
       * @return {number}
       */
      var mySqrt = function (x) {
        let i = 1;
        while (i * i <= x) {
          i++;
        }
        if (i * i > x) {
          i--;
        }

        return i;
      };
      // console.log(mySqrt(8));

      /*给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

               说明：本题中，我们将空字符串定义为有效的回文串。

               示例 1:

               输入: "A man, a plan, a canal: Panama"
               输出: true
               示例 2:

               输入: "race a car"
               输出: false
               */
      /**
       * @param {string} s
       * @return {boolean}
       */
      var isPalindrome = function (s) {
        const filterStrArr = [];
        const str = s.toLowerCase();
        for (let value of str) {
          if (/[0-9a-z]/.test(value)) {
            filterStrArr.push(value);
          }
        }
        let i = 0,
          j = filterStrArr.size() - 1;
        while (i < j) {
          if (filterStrArr[i] != filterStrArr[j]) return false;
          i++;
          j--;
        }

        return true;
      };

      /*
                 var isPalindrome = function (s) {
                         const initStr = s.toLowerCase().replace(/[^0-9a-z]/g, "");
                         const reverseStr = initStr.split("").reverse().join("");

                         return initStr === reverseStr;
                       };
             */
      // console.log(isPalindrome("A man, a plan, a canal: Panama"));
      /*
                 A -> 1
                 B -> 2
                 C -> 3
                 ...
                 Z  -> 26
                 AA -> 27
                 AB -> 28
                 AC -> 29

                 输入: "ZY"
                 输出: 701
             */
      /**
       * @param {string} s
       * @return {number}
       */
      //  A A = 26*1 +1
      //  B A =26*2 +1
      //  Z Y =26*26 +25

      //  A A A=1*26*26+1*26+26*0*1
      /*
             var titleToNumber = function (s) {
               const m = [
                 "A",
                 "B",
                 "C",
                 "D",
                 "E",
                 "F",
                 "G",
                 "H",
                 "I",
                 "J",
                 "K",
                 "L",
                 "M",
                 "N",
                 "O",
                 "P",
                 "Q",
                 "R",
                 "S",
                 "T",
                 "U",
                 "V",
                 "W",
                 "X",
                 "Y",
                 "Z",
               ];
               const hash = {};
               for (let i = 0; i < m.length; i++) {
                 hash[m[i]] = i + 1;
               }

               let result = 0;
               let k = 0;
               for (let j = s.length - 1; j > -1; j--) {
                 result += hash[s[j]] * Math.pow(26, k);
                 k++;
               }
               return result;
             };
             */
      var titleToNumber = function (s) {
        let sum = 0,
          i = s.length - 1,
          carry = 1;

        while (i >= 0) {
          let cur = s[i].charCodeAt() - 64;

          sum += cur * carry;
          carry *= 26;
          i--;
        }

        return sum;
      };
      /*

               给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

               说明：

               你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

               示例 1:

               输入: [2,2,1]
               输出: 1
               示例 2:

               输入: [4,1,2,1,2]
               输出: 4


             */
      /**
       * @param {number[]} nums
       * @return {number}
       */
      var singleNumber = function (nums) {
        result = "";
        for (let value of nums) {
          result ^= value;
        }
        return result;
      };
      // console.log(singleNumber([2, 2, 1]));

      /*
               给定一个整数 n，返回 n! 结果尾数中零的数量。



               示例 1:

               输入: 3
               输出: 0
               解释: 3! = 6, 尾数中没有零。
               示例 2:


               输入: 5
               输出: 1
               解释: 5! = 120, 尾数中有 1 个零.
               说明: 你算法的时间复杂度应为 O(log n) 。
                5*4*3*2*1  10

                10!=(2*5)*9*(2*2)*7*6*(1*5)*(2*2)*3*2*1   10*2*5

                15*14*13*12*11*10*9*8*7*6*5*4*3*2*1

                public int trailingZeroes(int n) {
                  int count = 0;
                  while (n > 0) {
                    count += n / 5;
                    n = n / 5;
                  }
                  return count;
                }
                public int trailingZeroes(int n) {
          int count = 0;
          while (n > 0) {
              n /= 5;
              count += n;
          }
          return count;
      }
             */

      /**
       * @param {number} n
       * @return {number}
       */
      // var trailingZeroes = function (n) {
      //   let count = 0;
      //   while (n > 0) {
      //     n = parseInt(n / 5);
      //     count += n;
      //   }
      //   return count;
      // };

      // console.log(trailingZeroes(15));
      /*
              给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

              示例 1:

              输入: [1,2,3,4,5,6,7] 和 k = 3
              输出: [5,6,7,1,2,3,4]
              解释:
              向右旋转 1 步: [7,1,2,3,4,5,6]
              向右旋转 2 步: [6,7,1,2,3,4,5]
              向右旋转 3 步: [5,6,7,1,2,3,4]
              示例 2:

              输入: [-1,-100,3,99] 和 k = 2
              输出: [3,99,-1,-100]
              解释:
              向右旋转 1 步: [99,-1,-100,3]
              向右旋转 2 步: [3,99,-1,-100]


            */

      /**
       * @param {number[]} nums
       * @param {number} k
       * @return {void} Do not return anything, modify nums in-place instead.
       */
      var rotate = function (nums, k) {
        for (let i = 0; i < k; i++) {
          nums.unshift(nums.pop());
        }
        return nums;
      };

      /*
              编写一个算法来判断一个数 n 是不是快乐数。

              「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

              如果 n 是快乐数就返回 True ；不是，则返回 False 。


              输入：19  2
              输出：true
              解释：
              12 + 92 = 82
              82 + 22 = 68
              62 + 82 = 100
              12 + 02 + 02 = 1
            */
      /**
       * @param {number} n
       * @return {boolean}
       */
      var isHappy = function (n) {
        if (n === 1) {
          return true;
        }
      };

      // console.log(rotate([1, 2, 3, 4, 5, 6, 7], 0));

      /*
               给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
              J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

              示例 1:
              输入: J = "aA", S = "aAAbbbb"
              输出: 3
              示例 2:

              输入: J = "z", S = "ZZ"
              输出: 0
              注意:

              S 和 J 最多含有50个字母。
              J 中的字符不重复。

              hash 表 法  与 暴力搜索

              查询某个数的时候,可以构建hash 表

            */
      /**
       * @param {string} J
       * @param {string} S
       * @return {number}
       */
      var numJewelsInStones = function (J, S) {
        let hash = {};
        for (let val of J) {
          hash[val] = val;
        }
        for (let value of S) {
          if (hash[value]) {
            i++;
          }
        }
        return i;
      };
      /*
                 var numJewelsInStones = function (J, S) {
              let i = 0;
              for (let value of S) {
                if (J.indexOf(value) > -1) {
                  i++;
                }
              }
              return i;
            };
            */
      // console.log(numJewelsInStones("aA", "aAAbbbb"));
      // console.log(numJewelsInStones("z", "ZZ"));
      /*
                编写一个程序判断给定的数是否为丑数。

                丑数就是只包含质因数 2, 3, 5 的正整数。

                示例 1:

                输入: 6
                输出: true
                解释: 6 = 2 × 3
                示例 2:

                输入: 8
                输出: true
                解释: 8 = 2 × 2 × 2
                示例 3:

                输入: 14
                输出: false
                解释: 14 不是丑数，因为它包含了另外一个质因数 7。
                说明：

                1 是丑数。
                输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。
            */
      /**
       * @param {number} num
       * @return {boolean}
       */
      var isUgly = function (num) {
        // 排除负数
        if (num < 1) return false;
        while (num > 1) {
          if (num % 2 === 0) {
            num = num / 2;
            continue;
          }
          if (num % 3 === 0) {
            num = num / 3;
            continue;
          }
          if (num % 5 === 0) {
            num = num / 5;
            continue;
          }
          return false;
        }
        return true;
      };

      /*
              给定两个字符串 s 和 t，判断它们是否是同构的。

              如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

              所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

              示例 1:

              输入: s = "egg", t = "add"
              输出: true
              示例 2:

              输入: s = "foo", t = "bar"
              输出: false
              示例 3:

              输入: s = "paper", t = "title"
              输出: true
              说明:
              你可以假设 s 和 t 具有相同的长度

               ab
               aa



            */
      /**
       * @param {string} s
       * @param {string} t
       * @return {boolean}
       */

      var isIsomorphic = function (s, t) {
        if (s.length !== t.length) {
          return false;
        }
        let hash = {};

        const isHasValue = (val) => {
          return Object.values(hash).every((item) => {
            return val !== item;
          });
        };

        for (let i = 0; i < s.length; i++) {
          if (i === 0) {
            hash[s[i]] = t[i];
          }

          if (
            i !== 0 &&
            hash[s[i]] === undefined &&
            t[i] !== hash[t[i]] &&
            isHasValue(t[i])
          ) {
            hash[s[i]] = t[i];
          } else {
            if (hash[s[i]] !== t[i]) {
              return false;
            }
          }
        }
        return true;
      };

      // console.log(isIsomorphic("ab", "aa"));
      // console.log(isIsomorphic("egg", "add"));
      // console.log(isIsomorphic("bar", "foo"));
      // console.log(isIsomorphic("paper", "title"));

      /*
        给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

        动态规划,也就是dp

        示例:
        输入: [-2,1,-3,4,-1,2,1,-5,4],
        输出: 6
        解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
        进阶:

        如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

        先分解子问题

        [-2,1]<0 但是 1>0  所以结果为1
        [-2,1,-3] 结果为1>-3,但是
        [-2,1,-3,4]

      */
      /**
       * @param {number[]} nums
       * @return {number}
       */
      var maxSubArray = function (nums) {
        let ans = nums[i];
        let sum = 0;
        for (let val of nums) {
          if (sum > 0) {
            sum += val;
          } else {
            sum = val;
          }
          ans = Math.max(sum, ans);
        }

        return ans;
      };

      /*
        给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

        如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

        注意：你不能在买入股票前卖出股票。



        示例 1:
        买入 :i=1    7
        卖出  i=2    1
        输入: [7,1,5,3,6,4]
        输出: 5
        解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
            注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
        示例 2:

        输入: [7,6,4,3,1]
        输出: 0
        解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

        [2,4,1]

        2


      */

      /**
       * @param {number[]} prices
       * @return {number}
       */
      var maxProfit = function (prices) {
        let result = 0;
        for (let i = 0; i < prices.length; i++) {
          for (let j = i + 1; j < prices.length; j++) {
            if (prices[i] < prices[j]) {
              result = Math.max(prices[j] - prices[i], result);
            }
          }
        }
        return result;
      };

      var maxProfit = function (prices) {
        let result = 0;
        let fallIn = prices[0];

        for (let val of prices) {
          if (val > fallIn) {
            result = Math.max(val - fallIn, result);
          } else {
            fallIn = val;
          }
        }

        return result;
      };

      // console.log(maxProfit([7, 1, 5, 3, 6, 4]));
      // console.log(maxProfit([7, 6, 4, 3, 1]));

      /*
        实现 strStr() 函数。

        给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

        示例 1:

        输入: haystack = "hello", needle = "ll"
        输出: 2
        示例 2:

        输入: haystack = "aaaaa", needle = "bba"
        输出: -1
        说明:

        当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

        对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

      */
      /**
       * @param {string} haystack
       * @param {string} needle
       * @return {number}
       */
      var strStr = function (haystack, needle) {
        let L = needle.length,
          n = haystack.length;

        for (let start = 0; start < n - L + 1; ++start) {
          if (haystack.substring(start, start + L) === needle) {
            return start;
          }
        }
        return -1;
      };
      /*
          mississippi=issip
          
      */

      /**
       * @param {number} n
       * @return {number}
       */
      // var climbStairs = function (n) {
      //   let dp = [];
      //   if (n === 1) {
      //     return 1;
      //   }
      //   if (n === 2) {
      //     return 2;
      //   }
      //   dp[1] = 1;
      //   dp[2] = 2;
      //   for (let i = 3; i <= n; i++) {
      //     dp[i] = dp[i - 1] + dp[i - 2];
      //   }

      //   return dp[n];
      // };

      /*
给定一个二叉树，检查它是否是镜像对称的。

          后续遍历

        例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

            1
          / \
          2   2
        / \ / \
        3  4 4  3


        但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

            1
          / \
          2   2
          \   \
          3    3



      */

      /**
       * Definition for a binary tree node.
       * function TreeNode(val) {
       *     this.val = val;
       *     this.left = this.right = null;
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {boolean}
       */
      var isSymmetric = function (root) {};

      console.log(climbStairs(3));
    </script>
  </body>
</html>
