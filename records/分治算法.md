## 分治算法

分治算法,比较经典的算法思想,且看它的描述:把问题分割多 N 多个子问题,然后
求解子问题的答案,利用递归把子问题的结果返回.可以得出以下结论:

1. 一般把大问题进行分割,然后变成一对一求解
2. 一般配合递归,返回"子问题求解的结果,然后进行**合并**"

## 归并排序

最经典的运用分治算法思想进行排序,对一组 N 个无序数组排序,利用分治思想来解决此问题:

### 分割大问题成小问题

这或许是最难的一步,对于排序,我们一般的想法就是冒泡(两个 for 循环搞定),或者**选择排序**(每一轮循环,取最大值
或最小值,然后放在相应位置),**插入排序**(每一轮前后比较,小在前,大在后).切换分治的思想来考虑排序
我们可以先对两个数排序,产生排序后,我们再与第三个数进行排序,与此类推,最后成为一个排序
好了数组.可以看出,**最后的排序结果,依赖于前一轮的排序结果**,**也就是子问题的结果,通过递归进行组合成大问题的结果**,

#### 如何查找子问题

注意几个字眼,**分**,思考的方向,取两个数,求出**问题结果**,然后再拿这两个数与

```js
function mergeSort(array) {
  // 分解过程
  if (array.length > 1) {
    // {1}
    const { length } = array;
    const middle = Math.floor(length / 2); // {2}
    const left = mergeSort(array.slice(0, middle)); // {3}
    const right = mergeSort(array.slice(middle, length)); // {4}
    // console.log(left, right)

    array = merge(left, right); // {5}
  }
  //  分割后的子项以及 结构, 这里两个数据共用了
  return array;
}

function merge(left, right) {
  let i = 0; // {6}
  let j = 0;
  const result = [];
  // [1,2]  [3,4]
  while (i < left.length && j < right.length) {
    // {7}
    result.push(left[i] < right[j] ? left[i++] : right[j++]); // {8}
  }

  return result.concat(i < left.length ? left.slice(i) : right.slice(j)); // {9}
}
```
